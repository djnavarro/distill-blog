---
title: "Binding Apache Arrow to R"
description:
  Neque porro quisquam est qui dolorem ipsum quia dolor sit amet, 
  consectetur, adipisci velit # <---- UPDATE ME
author:
  - first_name: "Danielle"
    last_name: "Navarro"
    url: https://djnavarro.net
    affiliation: Voltron Data
    affiliation_url: https://voltrondata.com
    orcid_id: 0000-0001-7648-6578
date: 2022-01-18
preview: img/muhammad-haikal-sjukri--RMBf_xSf2U-unsplash.jpg
creative_commons: CC BY
citation_url: https://blog.djnavarro.net/binding-arrow-to-r
repository_url: https://github.com/djnavarro/distill-blog/
output:
  distill::distill_article:
    self_contained: false
    toc: true
params:
  slug: binding-arrow-to-r
  date: 2022-01-18
  repo: djnavarro/distill-blog
  site: https://blog.djnavarro.net/
---

<!----

checklist:
  - check the "update me" messages in YAML above
  - initialise the _renv folder with refinery::renv_new("name of post folder")
  - populate the lockfile with refinery::renv_snapshot("name of post folder")
  - update the _renv folder from snapshot with refinery::restore("name of post folder")

---->


<!--------------- setup post ----------------->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = TRUE)
refinery::renv_load(paste(params$date, params$slug, sep = "_"))

# save the built-in output hook
hook_output <- knitr::knit_hooks$get("output")

# set a new output hook to truncate text output
knitr::knit_hooks$set(output = function(x, options) {
  if (!is.null(n <- options$out.lines)) {
    x <- xfun::split_lines(x)
    if (length(x) > n) {
      # truncate the output
      x <- c(head(x, n), "....\n")
    }
    x <- paste(x, collapse = "\n")
  }
  hook_output(x, options)
})

# ensure that renv detects ggplot2 dependency
ggplot2::element_blank()
```


<!--------------- post ----------------->

So I have a new job. 

In my previous job as an academic, a large part of my work -- my favourite part, if I'm honest -- involved creating open access resources to help people use modern open source tools for data analysis. In my totally different role in developer relations at Voltron Data, a large part of my work involves, um ... *[checks job description]* ... creating open access resources to help people use modern open source tools for data analysis. Well okay then! 

I'd better get on that, I suppose?

I've been in my current role for a little over a week, and today my [first contribution](https://github.com/apache/arrow/pull/12173/) to Apache Arrow was merged. My contribution was very modest: I wrote some code that determines whether any given year is a leap year. It exactly mirrors the behaviour of the `leap_year()` function in the **lubridate** package, except that it can be applied to Arrow data. The code itself is not complicated, but it relies on a little magic and a deeper understanding of Arrow than I possessed two weeks ago.  This post is the story of how I learned this sorcery.

```{r}
#| echo = FALSE,
#| fig.align = "center",
#| fig.cap = "Julia and Quentin. Image via [giphy](https://media.giphy.com/media/xUA7b94cNgJ4qoi532/giphy-downsized-large.gif), copyright [syfy](https://www.syfy.com)"
knitr::include_graphics("https://media.giphy.com/media/xUA7b94cNgJ4qoi532/giphy-downsized-large.gif")
```

<aside>Yes I have been binge watching *The Magicians* lately. My preemptive apologies to everyone for all the GIFs.</aside>

## Why write this?

> The danger of sublimated trauma is a major theme in our story <br>
> &nbsp; &nbsp; -- The Great God Ember (The Magicians: Season 2, Episode 3)

It might seem peculiar that I'm writing such a long post. After all, you only need one line of code to detect leap years:

```{r, eval=FALSE}
(year %% 4 == 0) & ((year %% 100 != 0) | (year %% 400 == 0))
```

This is a logical expression corresponding to the following rules. If the `year` is divisible by 4 then it is a leap year (e.g., 1996 was a leap year). But there's an exception: if `year` is divisible by 100 then it isn't a leap year (e.g., 1900 wasn't a leap year). But there's also an exception to the exception: if `year` is divisible by 400 then it is a leap year (e.g., 2000 was a leap year). Sure, it's mildly annoying trying to work out the logical expression that maps onto these rules, but there's no "special" magic here. 

The magic part comes in when we want to write R code that allows the user to specify this calculation in R using standard function and returning the results in R ... while the data are never loaded into R and the computation is done by Apache Arrow. That part feels like deep magic! 

It took me quite a bit of digging around to get myself into the position where I understood these things. This was (comparatively!) easy for me because I work at an organisation that contributes a lot of code to the Apache Arrow project. In my day to day work I can ask my lovely Voltron Data colleagues for help. Without their support I'm not sure I'd have been brave enough to try to contribute my own code to the project. With that in mind, one of my goals is to help "pay it forward". I'd like to take what I've learned from those conversations and make that knowledge more widely accessible. 

Before diving in, I should say something about the "assumed knowledge" for this post. I'm assuming that the reader is comfortable in R, are comfortable with git and GitHub, knows how to use dplyr for data manipulation, and has some vague familiarity with what Apache Arrow is all about. If you don't have the last one, do not fear: I wrote a post on ["Getting started with Apache Arrow"](https://blog.djnavarro.net/starting-apache-arrow-in-r) that covers the assumed knowledge about Arrow! 


## The Arrow C++ compute kernel

A fundamental thing to understand about the **arrow** package in R is that it doesn't implement Apache Arrow directly. There's a C++ library that does that in a super efficient way, and the job of the R package is to supply bindings that allow the R user to interact with that library using a familiar interface. The C++ library is called **libarrow**. Although the long term goal is to make the integration so seamless that you can use the **arrow** R package without ever *needing* to understand the C++ library, my experience has been that most people *want* to know something about what's happening under the hood. It can be unsettling to find yourself programming with tools you don't quite understand, so I'll dig a little deeper in this post.

Let's start with the C++ library. The role of **libarrow** is to do all the heavy lifting. It implements all the Arrow standards for representing tabular data in memory, provides support for the Apache "Inter-Process Communication" (IPC) protocol that lets you efficiently transfer data from one application to another, and supplies a *compute kernel* that allows you to do some data wrangling when your data are represented as an Arrow table. It is, fundamentally, the engine that makes everything work.

What about the R package? The role of **arrow** is to expose the functionality of **libarrow** to the R user, to make that functionality feel "natural" in R, and to make it easier for R users to write Arrow code that is smoothly interoperable with Arrow code written in other languages (e.g., Python). 

```{r}
library(tibble)
library(dplyr)
library(lubridate)
library(arrow)

# import the economics data from ggplot2
data(economics, package = "ggplot2")
economics

# create an analogous arrow Table
arrownomics <- arrow_table(economics)
arrownomics
```




## Using the **dplyr** bindings in **arrow** 

The **arrow** package provides you with multiple ways to take advantage of **libarrow**. My favourite way to do this is by writing **dplyr** code. 

```{r}
economics %>% 
  mutate(year = year(date)) %>% 
  group_by(year) %>% 
  summarise(uempmed = mean(uempmed))
```

Seamless integration:

```{r}
arrownomics %>% 
  mutate(year = year(date)) %>% 
  group_by(year) %>% 
  summarise(uempmed = mean(uempmed)) %>% 
  collect()
```

To see that this is all happening inside Arrow:

```{r}
arrownomics %>% 
  mutate(year = year(date)) %>% 
  group_by(year) %>% 
  summarise(uempmed = mean(uempmed)) %>% 
  compute()
```

The nice thing for R users is that *absolutely nowhere do you have to interact with* **libarrow** *directly*. Under the hood **libarrow** is doing all the computation -- none of the real work is being done within R -- but the user really doesn't need to worry too much about that. It all happens seamlessly and invisibly. 

That's the ideal.

But maybe you want to know more about what is going on. Maybe you hope to make a contribution to Arrow yourself. Maybe you need to access some of the **libarrow** functionality directly. If that's you, read on!

## Calling **libarrow** functions in **dplyr** code

The **dplyr** back end is the way users would typically use **arrow**, but there's nothing stopping you from calling the C++ compute functions directly. The `list_compute_functions()` function tells you what they are:

```{r, out.lines = 10}
list_compute_functions()
```

I've truncated the output in this post. The real output continues for quite a while: there are currently `r length(list_compute_functions())` **libarrow** compute functions that **arrow** exposes to the R user, most of which low level functions that the R package relies upon.

There are two different ways that an R user can call the **libarrow** compute functions. First, imagine you're writing **dplyr** code to work with datetime data in a Table object. When working with native R objects, you can do this:

```{r}
economics %>% 
  mutate(days = date - as.Date("1967-01-01"))
```

Unfortunately, this won't work in **arrow** right now. I chose this example deliberately because temporal arithmetic is a work in progress right now. In the not-too-distant future this will work seamlessly, but right now it doesn't. If you try it right now, you get this error:

```{r, error=TRUE}
arrownomics %>% 
  mutate(days = date - as.Date("1967-01-01")) %>% 
  collect()
```

This is very sad, but as it happens **libarrow** does have a `days_between()` function:

```{r}
arrownomics %>% 
  mutate(days = arrow_days_between(as.Date("1967-01-01"), date)) %>% 
  collect()
```
Notice there's no warning message here? That's because the computations were done in Arrow, using the **libarrow** `days_between()` function.


## Calling **libarrow** functions directly

Okay, here's a puzzle:

```{r, error=TRUE}
date1 <- as.Date("1967-01-01")
date2 <- as.Date("2022-01-18")

arrow_days_between(date1, date2)
```

There is no R function called `arrow_days_between()`, yet I was somehow able to "call" it in the previous example? The answer here is that the **arrow** package is doing a bit of metaprogramming magic. What's actually happening here is that when you use it in the **dplyr** context, **arrow** will intercepts the call to `arrow_days_between()` and quietly pass it to **libarrow** for you. 

If you *really* want to do it directly, you can use `call_function()` from the **arrow** package. This provides you with direct access to a **libarrow** function. It won't take care of the low-level communication between R and Arrow though: the **libarrow** functions expect to receive Arrow-native data structures as input. That's the price you pay for low-level access: you have to do all the low-level work!

```{r}
arrow_date1 <- Scalar$create(date1)
arrow_date2 <- Scalar$create(date2)

arrow_date1
```


Now you can do this:

```{r}
call_function("days_between", arrow_date1, arrow_date2)
```


## Writing functions that play nicely with arrow pipes

```{r}
arrowish_leap_year <- function(date) {
   year <- Expression$create("year", date)
  (year %% 4 == 0) & ((year %% 100 != 0) | (year %% 400 == 0))
}
```

Trying to use lubridate fails:

```{r}
arrownomics %>% 
  mutate(leap = leap_year(date)) %>% 
  collect()
```

Using our function works:

```{r}
arrownomics %>% 
  mutate(leap = arrowish_leap_year(date)) %>% 
  collect()
```



## Epilogue: The rest of the owl

The story I've told in this post is a little incomplete. I've shown you how to write a function like `arrowish_leap_year()` that can slot into a **dplyr** pipeline and operate on an Arrow data structure. What I haven't explained is how the **arrow** package knows to use `arrowish_leap_year()` instead of `lubridate::leap_year()`. Internal to the **arrow** package is a line of code that is (essentially) equivalent to this:

```{r, eval=FALSE}
register_binding("leap_year", arrowish_leap_year)
```

I haven't said anything about the precise workings of `register_binding()`, in part because that's one of the mysteries I'm currently unpacking while I dig into the code base.

But that's not the only thing I've left unsaid. There's a lot of practical details I've not mentioned. I haven't talked about unit tests, for example. I haven't talked about the process of getting my code merged into the Arrow repository. I'll talk more about some of these in the follow up post on ["My first contribution to Apache Arrow"](https://blog.djnavarro.net/contributing-to-arrow).

<!--------------- appendices ----------------->

```{r, echo=FALSE}
refinery::insert_appendix(
  repo_spec = params$repo, 
  name = paste(params$date, params$slug, sep = "_")
)
```


<!--------------- miscellanea ----------------->

```{r redirect, echo=FALSE}
refinery::insert_netlify_redirect(
  slug = params$slug, 
  date = params$date
)
```




