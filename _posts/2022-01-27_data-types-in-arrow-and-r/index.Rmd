---
title: "Data types in Arrow and R" # <---- UPDATE ME
description:
  Neque porro quisquam est qui dolorem ipsum quia dolor sit amet, 
  consectetur, adipisci velit # <---- UPDATE ME
author:
  - first_name: "Danielle"
    last_name: "Navarro"
    url: https://djnavarro.net
    affiliation: Voltron Data
    affiliation_url: https://voltrondata.com
    orcid_id: 0000-0001-7648-6578
date: 2022-01-27
preview: img/cover.jpg  # <---- UPDATE ME 
creative_commons: CC BY
citation_url: https://blog.djnavarro.net/data-types-in-arrow-and-r 
repository_url: https://github.com/djnavarro/distill-blog/
output:
  distill::distill_article:
    self_contained: false
    toc: true
params:
  slug: data-types-in-arrow-and-r
  date: 2022-01-27
  repo: djnavarro/distill-blog
  site: https://blog.djnavarro.net/
---

<!----

checklist:
  - check the "update me" messages in YAML above
  - initialise the _renv folder with refinery::renv_new("name of post folder")
  - populate the lockfile with refinery::renv_snapshot("name of post folder")
  - update the _renv folder from snapshot with refinery::restore("name of post folder")

---->


<!--------------- setup post ----------------->

```{r setup, include=FALSE}
tz <- .sys.timezone
.sys.timezone <- "UTC"
knitr::opts_chunk$set(echo = TRUE)
refinery::renv_load(paste(params$date, params$slug, sep = "_"))
```


<!--------------- post ----------------->

> Manuals for translating one language into another can be set up in divergent ways, all compatible with the totality of speech dispositions, yet incompatible with one another <br>
> &nbsp; &nbsp; -- William Van Orman Quine, 1960, [Word and Object](https://en.wikipedia.org/wiki/Word_and_Object)


<!-- 
TODO: 

Insert the point from conversation with Jon. The code the read_* functions is
complicated. It handles everything for you because "reading the data" is a 
constrained task. That means the developers can optimise almost everything. 

In contrast, the code underpinning schema() etc is simple. It takes care of 
choices for you when those choices are "obvious", but it leaves all the edge
cases for you to deal with. There are a lot of weird edge cases because 
"translating between languages" is underdetermined and can only ever be 
approximate. The developers can help make it easier, but the user has to be
the final arbiter, and it helps to understand what each language is "doing". 

-->

Consider this piece of magic


```{r}
library(tibble)
library(dplyr)
library(arrow)

magicians <- read_csv_arrow("magicians.csv")
magicians

arrowmagicks <- arrow_table(magicians)
arrowmagicks
```

The `magicians` data set is a "data frame" (a tibble, technically) stored in R. The `arrowmagicks` data set, however, is a pointer to a data structure stored in Arrow. That data structure is a "Table" object. Arrow Tables are roughly analogous to data frames -- both represent tabular data with columns that may be of different types -- but they are not the same. An act of *translation* has occurred. Similarly when we look at the individual columns we see that something similar has happened. "Integer" columns in R are mapped to "int32" columns in Arrow, "Date" columns in R become "date32" columns in Arrow, and so on. Even without knowing much about the data types in the two languages, you can infer a lot from the names! In this case you can reasonably (and correctly) infer that the translation from R to Arrow is a sensible one. Better yet, in this case, when we pull the `arrowmagicks` data back into R we recover the original data:

```{r}
collect(arrowmagicks)
```

In this example the translation back and forth "just works". You really don't have to think too much about the subtle differences in how Arrow and R "think about the world" and how their data structures are organised. And in general that's what we *want* in a multi-language toolbox: we want the data analyst to be thinking about the data, not the cross-linguistic subtleties of the data structures! 

## Defining schemas

That being said, it's also valuable to give the data analyst flexibility. The **arrow** package makes very sensible default choices about how to translate an R data structure into an Arrow data structure, but those choices can never be more than defaults because of the fundamental fact that the languages are inherently different. The quote about the [indeterminacy of translation](https://en.wikipedia.org/wiki/Indeterminacy_of_translation) at the top of this post was originally written about natural languages, but I think it applies in programming too. There's no "single" rulebook that tells you how to translate between R and Arrow: there can't be. 

Suppose that I knew that there would in fact be a "Season 5.1648" coming, consisting of a single episode whose title corresponded to the full text of the [Treaty of Westphalia](https://is.muni.cz/el/1423/podzim2008/MVZ430/um/Treaty-of-Westphalia.pdf). Knowing that this new data point is coming, I'd perhaps want my Arrow data to encode `season` as a numeric variable, and I'd probably want to recognise that the text in the `title` field can be quite long. To do that I can specify an explicit *schema* that tells the **arrow** package how to translate my R data set into Arrow. I can do this with the `schema()` function:

```{r}
translation <- schema(
  season = float64(), # not the default
  episode = int32(),
  title = large_utf8(), # not the default
  air_date = date32(),
  rating = float64(),
  viewers = float64()
)
```

Now I can use my schema to govern the translation:

```{r}
arrowmagicks2 <- arrow_table(magicians, schema = translation)
arrowmagicks2
```

This is of course a very silly example. But the underlying issue is fairly serious. 

## Why mapping languages is hard

Blah blah I used to teach categorisation and mental representation. Organising the world into concepts (or data structures) is hard. We define ontologies that impose order on a chaotic world. A famous attempt to do this in 1668 by John Wilkins in [An Essay Towards a Real Character, and a Philosophical Language](https://www.google.com.au/books/edition/_/BCCtZjBtiEYC?hl=en&gbpv=1). A small snippet taken from the section "On Beasts":

> BEASTS, may be distinguished by their several shapes, properties, uses, food, their tameness or wildness, etc. into such as are either
> 
> - VIVIPAROUS; producing living young.
> 
>     - WHOLE FOOTED, the *soles* of whose *feet* is are undivided, being used chiefly for *Carriage*. I.
>     - CLOVEN FOOTED. II. <br>
>       *Clawed*, or *multifidous*; the end of whose *feet* is branched out into *toes*; whether
>       
>         - NOT RAPACIOUS. III.
>         - RAPACIOUS; living upon the prey of other *Animals*; having generally *six short pointed* incisors, or *cutting teeth*, and *two long fangs* to hold their prey; whether the
>         
>             - CAT-KIND; having a *roundish head*. IV.
>             - DOG-KIND; whose *heads* are *more oblong*. V.
>             
> - OVIPAROUS; breeding *Eggs*. VI.

It goes on to elaborate. As a scientific taxonomy it's... interesting. But even psychologically it betrays the peculiarities of the author. Wilkins had the noble ambition of defining a "universal language", but as a 17th century English gentleman there are certain deficiencies! I note as an Australian that there's no distinction between placental and marsupial mammals here! But of course the problems are more general. In 1952 the Argentinian author Jorge Luis Borges published an essay called [The Analytical Language of John Wilkins](https://ccrma.stanford.edu/courses/155/assignment/ex1/Borges.pdf) and describes a classification system from an fictitious "Celestial Emporium of Benevolent Knowledge":

> In its remote pages it is written that the animals are divided into: (a) belonging to the emperor, (b) embalmed, (c) tame, (d) sucking pigs, (e) sirens, (f) fabulous, (g) stray dogs, (h) included in the present classification, (i) frenzied, (j) innumerable, (k) drawn with a very fine camelhair brush, (l) et cetera, (m) having just broken the water pitcher, (n) that from a long way off look like flies

It's pretty unlikely that any human language would produce a classification system quite as chaotic as Borges' fictional example, but the point is well made. Actual classification systems used in different languages and cultures are very different to one another and often feel very alien when translated. Michel Foucault actually refers to this Borges passage in the preface to his famous work [The Order of Things: An Archaeology of the Human Sciences](https://en.wikipedia.org/wiki/The_Order_of_Things) on how different cultures and historical periods viewed the world from fundamentally different perspectives. According to Foucault, Borges essay 

> shattered ... all the familiar landmarks of thought --- our thought, the thought that bears the stamp of our age and our geography --- breaking up all the ordered surfaces and all the planes with which we are accustomed to tame the wild profusion of existing things



## Translating data types

So how do we construct data structures in Arrow that are appropriate translations of data structures in R, and vice versa? For the moment, let's keep things simple and assume that the mapping we're interested in has the same format as the one described at the start of the post: in R we want to encode the data as a data frame, and in Arrow we want to encode it as a Table. If so, the translation question is really a matter of how we encode the columns.

In the rest of this post I'll use a lot of diagrams showing the default mappings that the **arrow** package uses when converting data columns from R to Arrow and vice versa. In each case I'll show R data types on the left hand side (against a blue background) and Arrow data types on the right hand side (against an orange background), as shown below:

```{r}
#| echo = FALSE,
#| fig.align = "center",
#| fig.cap = "Illustration of the graphical convention used in the later   diagrams, showing R on the left side (against a blue background) and Arrow on the right side (against an orange background)."

knitr::include_graphics("img/visual-convention.png", dpi = 100)
```

<aside><br>Instead of using alt-text, I've included verbose and descriptive figure captions that verbally describe the content of each diagram</aside>

## Logical types

<!-- 
TODO: add discussion of two-valued and three-valued logics here
-->

I'll start with the simplest possible case: a data frame with one column of logical data. Logical data in R can take on three possible values: `TRUE` and `FALSE` are the two allowed truth values, and `NA` is used to denote missing data. 

```{r}
df <- tibble(values = c(TRUE, FALSE, NA))
df
```

Arrow has an analogous "boolean" type, which has truth values `true` and `false`. Just like R, missing values are allowed, and are represented as `null`. Arrow booleans and R logicals are essentially equivalent to one another, so by default the **arrow** package will map an R logical to an Arrow boolean and vice versa.

```{r}
#| echo = FALSE,
#| fig.align = "center",
#| fig.cap = "Default mappings for logical types"

knitr::include_graphics("img/logical-types.png", dpi = 100)
```

So let's do it:

```{r}
tb <- arrow_table(df)
tb
```

It's mildly annoying this doesn't print out the actual values. Happily the **arrow** package supplies a `$` operator for Arrow Table objects so we can do this:

```{r}
tb$values
```

Okay, that makes sense. The "ChunkedArray" bit might seem a little unfamiliar to R users -- and I'll come back to it later -- but for now we can imagine it's something similar to an R vector. 

This also tells us a little more about the relationship between R data frames and Arrow Tables. In R, a data frame is a collection of equal-length vectors; in Arrow, a Table is a collection of equal-length chunked arrays. This is convenient for me because I can use the `chunked_array()` function for the rest of this section. Instead of going through that elaborate process of creating a tibble and then calling `arrow_table()` I could have just done this:

```{r}
values <- c(TRUE, FALSE, NA)
chunked_array(values)
```

<!-- 
TODO: foreshadow that the NA, null thing will be explained later
-->



## Integer types

Integers are a little more complicated: where base R provides just the one integer type, Arrow provides eight. 

To make sense of the different types, it helps to take a moment to think about how integers are represented in a binary format. Let's suppose we allocate 8 bits to specify an integer. If we do that, then there are $2^8 = 256$ unique binary patterns we can create with these bits. Because of this, there is a fundamental constraint: no matter how we choose to set it up, 8-bit integers can only represent 256 distinct numbers. Technically, we could choose any 256 numbers we like, but in practice there are only two schemes used for 8-bit integers: *unsigned* 8-bit integers ("uint8") use those bits to represent integers from 0 to 255, whereas *signed* 8-bit integers ("int8") can represent integers from -128 to 127. 

<!-- 
TODO:

Mathematically: 
  signed = the integers, Z
  unsigned = the naturals, N
-->

More generally, an unsigned n-bit integer can represent integers from 0 to $2^n - 1$, whereas a signed n-bit integer can represent integers from $-2^{n-1}$ to $2^{n-1} - 1$. Here's what that looks like for all the integer types supported by Arrow:

| Description     | Name   | Smallest Value       |        Largest Value |
| --------------- | -----: | -------------------: | -------------------: |
| 8 bit unsigned  | uint8  | 0                    |                  255 |
| 16 bit unsigned | uint16 | 0                    |                65535 |
| 32 bit unsigned | uint32 | 0                    |           4294967295 |
| 64 bit unsigned | uint64 | 0                    | 18446744073709551615 |
| 8 bit signed    | int8   | -128                 |                  127 |
| 16 bit signed   | int16  | -32768               |                32767 |
| 32 bit signed   | int32  | -2147483648          |           2147483647 |
| 64 bit signed   | int64  | -9223372036854775808 |  9223372036854775807 |

On the R side, the integer type supplied by base R is a 32 bit signed integer, and has a natural one-to-one mapping to the Arrow int32 type. Because of this, the **arrow** default is to convert an R integer to an Arrow int32 and vice versa. 

What about the other seven Arrow types? This is where it gets a little trickier. The table above illustrates that some integer types are fully contained within others: unsurprisingly, every number representable by int16 can also be represented by int32, so we can say that the int16 numbers are fully "contained" by (i.e. are a proper subset of) the int32 numbers. Similarly, uint16 is contained by unit32. There are many cases where an unsigned type is contained by a signed type: for instance, int32 contains all the uint16 numbers. However, because the unsigned integers cannot represent negative numbers, the reverse is never true. So we can map out the relationships between the different types like this: 

```{r}
#| echo = FALSE,
#| fig.align = "center",
#| fig.cap = "Containment relationships between the integer types."

knitr::include_graphics("img/integer-types-03.png", dpi = 350)
```

Whenever type A contains type B, it's possible to transform an object of type B into an object of type A without losing information or requiring any special handling. R integers are 32 bit signed integers, which means it's possible to convert Arrow data of types int32, int16, int8, uint16, and uint8 to R integers completely painlessly. So for these data types the **arrow** defaults give us this relationship:

```{r}
#| echo = FALSE,
#| fig.align = "center",
#| fig.cap = "Default mappings for some integer types"

knitr::include_graphics("img/integer-types-01.png", dpi = 100)
```

Other integer types are messier. To keep things nice and simple, what we'd *like* to do is to map the Arrow uint32, uint64, and int64 types onto the R integer type. Sometimes that's possible: if all the stored values fall within the range of values representable by R integers (i.e., are between -2147483648 and 2147483647) then we can do this, and that's what **arrow** does by default. However, if there are values that "overflow" this range, then **arrow** will import the data as a different type, as shown below:

```{r}
#| echo = FALSE,
#| fig.align = "center",
#| fig.cap = "Default mappings for other integer types"

knitr::include_graphics("img/integer-types-02.png", dpi = 100)
```

If this diagram looks ugly and unhelpful, well... yeah, I agree. Translations become messy when the boxes in one language don't quite match up to the content expressed in another. Sometimes it's just easier to see the system in action, so let's write a little helper function:

```{r}
translate_integer <- function(value, type) {
  value_arrow <- Scalar$create(value, type)
  value_r <- value_arrow$as_vector()
  return(c(
    arrow = value_arrow$type$name,
    r = class(value_r)
  ))
}
```

The `translate_integer()` function takes an integer `value` and an `type` as input, and it returns a vector that tells you what Arrow type was created (this should be identical to `type`), and what R class gets returned when we import that Arrow object back into R. 

To illustrate, let's encode the number 10 as an unsigned 8-bit integer in Arrow and then see what happens when that gets pulled back into R. This is an easy case because uint8 always maps back to integer:

```{r}
translate_integer(value = 10, type = uint8())
```

Next, let's see how **arrow** handles the three types that are a little awkward for R to represent as integers. First, let's see what happens when all the values are small enough that R actually *can* represent them as integers:

```{r}
translate_integer(value = 10, type = uint32())
translate_integer(value = 10, type = uint64())
translate_integer(value = 10, type = int64())
```

Okay, that makes sense. If the numbers *can* be represented using the R integer class then that's what **arrow** will do. 

Now let's increase the number to something that R cannot represent as an integer, and see what happens:

```{r}
translate_integer(value = 3000000000, type = uint32())
translate_integer(value = 3000000000, type = uint64())
translate_integer(value = 3000000000, type = int64())
```

The last result might be a little surprising to many R users. The integer64 class is supplied by the **bit64** package, and provides an R class that behaves like 64-bit integers in R. 

Just to complicate matters, there's a special option for uint64 that you can use to force **arrow** to always return integer64:

```{r}
options(arrow.int64_downcast = FALSE)
translate_integer(value = 10, type = int64())
```

Anyway. That's the whole story. Just need to make it coherent!

Before moving on, allow me to clean up state:

```{r}
options(arrow.int64_downcast = NULL)
```



## Numeric types

<!-- 
TODO:
Mathematically: floating points as approximations to the reals. uncountable infinity is a bitch
-->



```{r}
#| echo = FALSE,
#| fig.align = "center",
#| fig.cap = "Default mappings for numeric types"

knitr::include_graphics("img/numeric-types.png", dpi = 100)
```


## Character types

Strings are an interesting case. R uses a single data type to represent strings (character vectors) but Arrow has two types, known as strings and large strings. When using the **arrow** package, Arrow strings are specified using the `utf8()` function, and large strings correspond to the `large_utf8()` type. The default mapping is to assume that an R character vector maps onto the Arrow `utf8()` type, as shown below:

```{r}
#| echo = FALSE,
#| fig.align = "center",
#| fig.cap = "Default mappings for character types"
knitr::include_graphics("img/character-types.png", dpi = 100)
```

There's a little more than meets the eye here though, and you might be wondering about the difference between "strings" and "large strings" in Arrow, and when you might prefer one to the other. As you might expect, the large string type is suitable when you're storing large amounts of text, but to understand it properly I need to talk in more depth about how R and Arrow store strings, and I'll use this little snippet of song lyrics from *A Simple Goodbye* by [The Cruel Sea](https://en.wikipedia.org/wiki/The_Cruel_Sea_(band))

```
won't try and make you stay
you won't even have to say
bye-bye
bye-bye
bye-bye
```

Suppose I want to store this as a character vector in R, with one word per element. To do that I might write code like this:

```{r}
lyrics <- c(
  "won't", "try", "and", "make", "you", "stay", 
  "you", "won't", "even", "have", "to", "say",
  "bye-bye", "bye-bye", "bye-bye"
)
```

Each element of the `lyrics` vector is a variable-length string, and is stored internally by R as an array of individual characters^[As noted in the R internals manual, the specific data structure is referred to as a [CHARSXP](https://cran.r-project.org/doc/manuals/r-release/R-ints.html#Encodings-for-CHARSXPs). For the purposes of the current post I'm pretending that character strings are always encoded as UTF-8 because there's no need to complicate matters by talking about things like Latin-1, but be aware that R does support those things. If you're looking for a good overview of what UTF-8 encoding is all about, this blog post on [how unicode works](https://deliciousbrains.com/how-unicode-works/) is helpful.]

blah blah global string pool in R 

Arrow takes a different approach. As it was explained to me "String arrays in Arrow don't store individual strings. All the string data is stored end to end in one long buffer. A separate buffer of offsets is used to track where each string begins/ends. Normal string arrays use 32-bit offsets, large string arrays use 64-bit offsets" 

okay, so why do I care? well, if you're using 32-bit integers to encode the offset, that imposes a limit on the total number of characters that can be included. The total size of the string array is capped at 2GiB because you don't have a way of referring to positions in the string larger than that. if you use 64-bit integers to encode the offset, that limit goes away (I mean technically there is a limit of course because 64-bit is still finite precision but it's *quite* a lot bigger). 


## Date/time types

<!--
TODO
Quine has a smartarse quote about time being lingustically special
-->


Next up on our tour of data types are dates and times. Internally, R and Arrow both adopt the convention of measuring time in terms of the time elapsed since a specific moment in time known as the [unix epoch](https://en.wikipedia.org/wiki/Unix_time). The unix epoch is the time 00:00:00 UTC on 1 January 1970. Unfortunately, it was a Thursday.

On the R side of things, a Date object is represented internally as a numeric value, counting the number of days since the unix epoch. Here is today as a Date:

```{r}
today <- Sys.Date()
today
```

If I use `unclass()` to see what it looks like under the hood:

```{r}
unclass(today)
```

A date is a comparatively simple thing. When we want to represent dates and time together, we nee we need to know the time of day, and we usually need to store information about the timezone as well. Base R has two different classes for representing this, POSIXct and POSIXlt. These names used to confuse me a lot. [POSIX](https://en.wikipedia.org/wiki/POSIX) stands for "portable operating system interface", and it's a set of standards used to help operating systems remain compatible with each other. In this context though, it's not very meaningful: all it says "yup we use unix time." 

The more important part of the name is actually the ["ct" versus "lt"](https://stackoverflow.com/questions/44778721/what-do-ct-and-lt-in-posixct-and-posixlt-mean) part. Let's start with POSIXct. The "ct" in POSIXct stands for "calendar time": internally, R stores the number of seconds that have elapsed since 1970-01-01 00:00 UTC.

```{r}
now <- Sys.time()
now
```

If I peek under the hood using `unclass()` here's what I see:

```{r}
unclass(now)
```

The "lt" in POSIXlt stands for "local time", and the underlying data structure is quite different:

```{r}
unclass(as.POSIXlt(now))
```


```{r}
#| echo = FALSE,
#| fig.align = "center",
#| fig.cap = "Default mappings for date/time types"
knitr::include_graphics("img/date-types.png", dpi = 100)
```

```{r}
#| echo = FALSE,
#| fig.align = "center",
#| fig.cap = "Default mappings for duration types"
knitr::include_graphics("img/duration-types.png", dpi = 100)
```

## Other types

```{r}
#| echo = FALSE,
#| fig.align = "center",
#| fig.cap = "Default mappings for null types"
knitr::include_graphics("img/null-types.png", dpi = 100)
```

```{r}
#| echo = FALSE,
#| fig.align = "center",
#| fig.cap = "Default mappings for raw types"
knitr::include_graphics("img/raw-types.png", dpi = 100)
```

```{r}
#| echo = FALSE,
#| fig.align = "center",
#| fig.cap = "Default mappings for factor types"
knitr::include_graphics("img/factor-types.png", dpi = 100)
```


```{r}
#| echo = FALSE,
#| fig.align = "center",
#| fig.cap = "Default mappings for data frame types"
knitr::include_graphics("img/dataframe-types.png", dpi = 100)
```


## Resources

- https://arrow.apache.org/docs/r/articles/arrow.html
- https://arrow.apache.org/docs/cpp/api/datatype.html



```{r, echo=FALSE}
.sys.timezone <- tz
```

<!--------------- appendices ----------------->

```{r, echo=FALSE}
refinery::insert_appendix(
  repo_spec = params$repo, 
  name = paste(params$date, params$slug, sep = "_")
)
```


<!--------------- miscellanea ----------------->

```{r redirect, echo=FALSE}
refinery::insert_netlify_redirect(
  slug = params$slug, 
  date = params$date
)
```




