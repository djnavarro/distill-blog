---
title: "Data serialisation in R"
description:
  Understanding the relationship between in-memory data structures in R and how
  those objects are converted to a sequence of bytes that can be saved or 
  transmitted.
author:
  - first_name: "Danielle"
    last_name: "Navarro"
    url: https://djnavarro.net
    affiliation: UNSW Sydney
    affiliation_url: https://unsw.edu.au
    orcid_id: 0000-0001-7648-6578
date: 2021-11-11
preview: preview-image.jpg  # <---- UPDATE ME 
creative_commons: CC BY
citation_url: https://blog.djnavarro.net/base-r-serialisation 
repository_url: https://github.com/djnavarro/distill-blog/
output:
  distill::distill_article:
    self_contained: false
    toc: true
params:
  slug: base-r-serialisation
  date: 2021-11-11
  repo: djnavarro/distill-blog
  site: https://blog.djnavarro.net/
---

<!----

checklist:
  - check the "update me" messages in YAML above
  - initialise the _renv folder with refinery::renv_new("name of post folder")
  - populate the lockfile with refinery::renv_snapshot("name of post folder")
  - update the _renv folder from snapshot with refinery::restore("name of post folder")

---->


<!--------------- setup post ----------------->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
refinery::renv_load(paste(params$date, params$slug, sep = "_"))
```


<!--------------- post ----------------->

Data [serialisation](https://en.wikipedia.org/wiki/Serialization) is one of those terms that comes up from time to time in data science (and on #rstats twitter!). I suspect that anyone who works with big data or has a computer science background is likely to be *painfully* aware of what serialisation is and why it matters. Those folks probably aren't in need of any post that I might write on the topic! However, a lot of people who work in R come from other backgrounds. If you're a social scientist who mostly works with small CSV files, for example, there's no particular reason why you'd have encountered this. I worked as a mathematical psychologist and computational modeller for about 20 years and until very recently I've never had never had to think about it! In fact, the issue only came up for me when I started reading about [Apache Arrow](https://arrow.apache.org) (a topic for another post, perhaps...) and realised that I needed to have a better understanding of what all this data serialisation business is about, and how R handles it. 

## What is serialisation?

Viewed in the general sense, serialisation refers to any process that takes an object stored in memory and converts into a stream of bytes that can be written to a file or transmitted elsewhere. Any time we write data to a file, we are "serialising" it according to some encoding scheme.  Suppose, for instance, I have a data frame called `art`:

```{r read-csv-hidden, echo=FALSE}
art <- read.csv("art.csv")
```
```{r show-art}
art
```

This data frame is currently stored in memory on my machine, and it has structure: R represents it as a list of length 6, where each element of the list points to an atomic vector (e.g., numeric, character, logical), accompanied by some additional metadata that tells R that this particular list is a data frame. The details of how this is accomplished don't matter for this post^[If you really want to torture yourself you can go look at the [R Internals Manual](https://cran.r-project.org/doc/manuals/r-release/R-ints.pdf)]: all that matters is that the in-memory structure for `art` is a little more complicated than a stream of bytes. If I want to save it to a data file, however, it needs to be converted into a stream of bytes: it needs to be **serialised**. Serialisation doesn't have to be fancy. The humble CSV file is a form of serialisation:

```{r write-csv}
write.csv(art, file = "art.csv", row.names = FALSE)
```

By doing this, the `art` object is written as UTF-8 encoded text onto the disk, as the file "art.csv". If we were to open this file in a text editor, we'd see this:


```{r print-text-csv, echo=FALSE}
print_text_csv <- function(file, nchars = 1000) {
  con <- file(file)
  chars <- readChar(con, nchars = nchars)
  close(con)
  return(chars)
}
cat(print_text_csv("art.csv"))
```

What you see in the text editor, however, isn't literally the raw sequence of bytes: you're looking at it as UTF-8 plain text. The file has already been unserialised and decoded. To get a sense of what the serialised data look like, note that the first few characters of the file are `"resolu"`, and we can use `charToRaw()` to convert these characters into a series of bytes:

```{r}
charToRaw('"resolu')
```

To see what the file looks like in serialised form, we can define a simple helper function that opens a binary connection to the file, reads in the first 100 bytes, closes the file, and then returns those bytes as a raw vector: 

```{r print-bytes-csv}
read_bytes <- function(path, max_bytes = 100) {
  con <- file(path, open = "rb")
  bytes <- readBin(con, what = raw(), n = max_bytes)
  close(con)
  return(bytes)
}

read_bytes("art.csv")
```

The `read.csv()` function is similar to `read_bytes()` in spirit: when I call `read.csv("art.csv")` R R opens a connection to the "art.csv" file and reads that sequence of bytes into memory, and then closes the file. However, unlike my simple `read_bytes()` function, it actually does something useful. The sequence of bytes gets decoded, or **deserialised**, and the result is that R reconstructs the original `art` data frame in memory:

```{r read-csv}
art <- read.csv("art.csv")
art
```

Thrilling stuff.

## How does RDS serialisation work?

Data can be serialised in different ways. The native RDS format used by R, for example, provides a method for serialising an R object in a way that -- unlike CSV -- preserves all the information about that object. When I use `readRDS()` to unserialise the `art.rds` file that I happen to have on disk, it clearly recreates the same R object

```{r read-rds}
readRDS("art.rds")
```

but when I read this file using `read_bytes()` it's equally clear that the file itself contains a very different sequence of bytes:

```{r read-rds-bytes}
read_bytes("art.rds")
```

To get a sense of how the RDS format works, it's helpful to note that R has a `serialize()` function and an `unserialize()` function that provide low-level access to the same mechanisms that underpin `saveRDS()` and `readRDS()`. 

```{r serialise-art}
bytes <- serialize(art, connection = NULL)
```

As you can see, this is the same sequence of bytes returned by `read_bytes()`...

```{r show-serialised}
bytes[1:100]
```

...oh wait, not it's not. The "art.rds" file begins with `1f 8b 08 00`, whereas `serialize()` returns a sequence of bytes that begins with `58 0a 00 00`. These are clearly not the same!

The reason this happens is that the default behaviour of `saveRDS()` is to write a compressed RDS file using gzip compression. The `art.rds` file that I have stored on disk is that gzipped version. That's a very sensible default, but it's easy enough to save an uncompressed RDS file, simply by setting `compress = FALSE`:

```{r save-uncompressed}
saveRDS(art, file = "art_nozip.rds", compress = FALSE)
```

When I inspect the uncompressed version of the RDS file using `read_bytes()`, the output is the same one I obtained when I called `serialize(art)` earlier:

```{r read-uncompressed}
read_bytes("art_nozip.rds")
```

The `unserialize()` function is very similar to `readRDS()`, and you can apply it to a raw vector like `bytes` and once again we reconstruct the data frame:

```{r unserialise-art}
unserialize(bytes)
```

Even more thrilling stuff than before. 

## Serialising to plain text RDS

Okay, so what we've learned so far is that in most cases, an RDS file is just a gzipped version of whatever the hell it is that `serialize()` creates. What we don't yet know is how the `serialize()` function operates. How is it creating this sequence of bytes? What do the contents of this file actually include? In order to look at this, I'll start by serialising a much simpler object. Instead of serialising the `art` data frame, I'll serialise a numeric vector containing three elements, and I'll set `ascii = TRUE` so that R uses UTF-8 to serialise the object to plain text format

```{r}
bytes <- serialize(
  object = c(10.1, 2.2, 94.3), 
  connection = NULL,
  ascii = TRUE
)
```

When I print out the UTF-8 vector I still don't get text though, I get the sequence of bytes that corresponds to that text:

```{r}
bytes
```

However, it's easy enough to use `rawToChar()` to convert the raw vector into a text that I can then print out using `cat()`:

```{r}
cat(rawToChar(bytes))
```

It's not immediately obvious how this output should be interpreted, but it's clear that the last three lines correspond to the three values stored in the numeric vector. In fact, what you're looking at is exactly the same text that you'd see if you created an RDS using the following command and then opened that file in a text editor:

```{r}
saveRDS(
  object = c(10.1, 2.2, 94.3), 
  file = "numbers.rds", 
  ascii = TRUE, 
  compress = FALSE
)
```

Yay! My excitement can barely be contained.

## Interpreting the RDS format

All right, lets see if we can interpret the contents of an RDS file. Rather than tediously writing the file to disk using `saveRDS()` and then loading it again, I'll cheat slightly and write a `show_rds()` function that serialises an object and prints the results directly to the R console:

```{r}
show_rds <- function(object, header = TRUE) {
  bytes <- serialize(
    object = object,
    connection = NULL, 
    ascii = TRUE
  )
  rds_string <- rawToChar(bytes)
  rds_vector <- strsplit(rds_string, "\n")[[1]]
  if(header == FALSE) rds_vector <- rds_vector[-(1:6)]
  cat(rds_vector, sep = "\n")
}
```

```{r}
show_rds(object = c(10.1, 2.2, 94.3))
```

We already know what the last 3 lines mean: they're the 3 values contained in the object. Is it a coincidence that line preceding that happens to *also* contain "3"? Let's see what happens if we try to serialise just 2 numbers. Does that line change to "2"?

```{r}
show_rds(object = c(10.1, 2.2))
```

Yes. Yes it does. Here's what we know so far:

```
A
3
262402
197888
5
UTF-8
14
3      # the object has length 3
10.1   # first value is 10.1
2.2    # second value is 2.2
94.3   # third value is 94.3
```

Okay, so what's next? The "14" in the preceding line. What does that mean? Well, if you happen to be the kind of person who has the [R Internals Manual](https://cran.r-project.org/doc/manuals/r-release/R-ints.pdf)] open at all times (and who doesn't amirite?), you would *obviously* that 14 is the internal `SEXPTYPE` code that R uses to specify that an object is a numeric vector. But just case you happen to be a human being with a life and doesn't have the R Internals Manual memorised, here's a few of the more common codes:

| Value | SEXPTYPE | Variable type   |
| ----- | -------- | --------------- | 
| 10    | LGLSXP   | logical         |
| 13    | INTSXP   | integer         |
| 14    | REALSXP  | numeric         |
| 16    | STRSXP   | character       |
| 19    | VECSXP   | list            |

So we can update our annotated description:

```
A
3
262402
197888
5
UTF-8
14     # the object is numeric
3      # the object has length 3
10.1   # first value is 10.1
2.2    # second value is 2.2
94.3   # third value is 94.3
```


### The RDS header

At this point, we've annotated every part of the RDS file that corresponds to the actual object. The lines preceding it are the RDS header. Here's what the first four lines mean:

```
A      # the file uses ASCII encoding
3      # the file uses version 3 of the RDS format
262402 # the file was written in R version 4.1.2
197888 # the minimum R version that can read it is 3.5
5
UTF-8 
```

At this point any sane person is probably wondering how the R versions are encoded. Why does version 4.1.2 correspond to the number 262402, and why does 3.5 get encoded as 197888? It was a complete mystery to me until I took a look at the internal [source code](https://github.com/wch/r-source/blob/79298c499218846d14500255efd622b5021c10ec/tools/GETVERSION#L11) which revealed the formula:

```{r}
encode_r_version <- function(major, minor, patch) {
  (major * 65536) + (minor * 256) + patch
}
```

Just to check:

```{r, results='hold'}
encode_r_version(4, 1, 2)
encode_r_version(3, 5, 0)
```

Okay, that all makes sense. What about the other two lines in the header? Prior to RDS version 3 (which was released in R version 3.5) those two lines didn't exist. Those are now used to specify the "native encoding" of the file. The "A" at the beginning of the RDS file is a little misleading: the RDS file format isn't restricted to ASCII characters. In the usual case, the RDS file can encode any [UTF-8 character](https://en.wikipedia.org/wiki/UTF-8). In some cases, however, the file may be restricted to the [Latin-1 alphabet](https://en.wikipedia.org/wiki/ISO/IEC_8859-1). Because of this, there is some ambiguity that needs to be resolved: the RDS file needs to indicate which character set is used for the encoding. So our annotated header now looks like this:

```
A      # the file uses ASCII encoding
3      # the file uses version 3 of the RDS format
262402 # the file was written in R version 4.1.2
197888 # the minimum R version that can read it is 3.5
5
UTF-8  # the file encodes UTF-8 characters not Latin-1
```

Okay then... but what about that pesky "5"? What does that mean? I'll be honest. It took me ages to figure this one out. As far as I can tell this line isn't discussed in the R Internals Manual, but you can work it out by looking at the [source code for serialize](https://github.com/wch/r-source/blob/79298c499218846d14500255efd622b5021c10ec/src/main/serialize.c#L1405-L1408). That line reads "5" because it's telling you (or the parser) that the string that follows on the next line (i.e., "UTF-8") contains 5 characters. Presumably if I'd used Latin-1 encoding, the corresponding line would have been "7". 

Now that we have a sense of how the RDS header works, I'll set `header = FALSE` whenever I call `show_rds()` from now on so that we don't have to look at that same six lines of output over and over!

### Logical, integer, and numeric vectors

For three of the four commonly used atomic vector types (logical, integer, and numeric), the RDS format looks exactly as you'd expect from the previous discussion. As shown in the table above, the SEXPTYPE code for a logical vector is 10, so a logical vector with four elements looks like this:

```{r}
show_rds(
  object = c(TRUE, TRUE, FALSE, NA), 
  header = FALSE
)
```

`TRUE` values are represented by `1` in the RDS file, and `FALSE` values are represented by `0`. Missing values are represented as `NA`. For an integer vector, we see something similar. The SEXPTYPE here is 13, so a vector of four integer looks like this:

```{r}
show_rds(
  object = c(-10L, 20L, 30L, NA),
  header = FALSE
)
```

Numeric vectors we've already seen. They have SEXPTYPE of 14, so a numeric vector of length 3 starts with `14` on the first line, `3` on the second line, and then the numbers themselves appear over the remaining three lines. However, one thing to keep in mind is that numeric values are subject to the vagaries of floating point arithmetic when represented in-memory, so it's quite possible that something like this might happen when those values are subsequently serialised:

```{r}
show_rds(
  object = c(10.3, 99.9, 100),
  header = FALSE
)
```

What about character vectors? Ah well, those are trickier...

### Character vectors

Let's create a simple character vector. According to the table above, character vectors have SEXPTYPE 16, so you'd expect that a character vector with three elements would start with `16` on the first line and `3` on the second line, which would then be followed by the contents of each cell. And that's... sort of true:

```{r}
show_rds(
  object = c("text", "is", "strange"),
  header = FALSE
)
```

What is slightly peculiar is that every string occupies three lines. For instance, these three lines correspond to the word `"strange"`:

```
262153
7
strange
```

This puzzled me at first, before I remembered that the source code for R is all written in C, and C represents strings as an array. In R, the word `"strange"` is treated as a single string, but C treats this string as a vector consisting of 7 characters. So the interpretation of lines two and three are:

```
262153
7        # the string has "length" 7
strange  # the 7 characters in the string
```

What about the first line? Given everything we've seen previously it's pretty tempting to guess that it means something similar to the SEXPTYPE codes that we've seen earlier. Perhaps in the same way that numeric is SEXPTYPE 14 and logical is SEXPTYPE 10, maybe there's some sense in which a single string has a "SEXPTYPE" of 262153? Turns out that's not true. The actual data structure here is called a CHARSXP -- referring to the internal representation R uses for character strings -- and it is SEXPTYPE 9. Later on I'll explain why all the strings are marked with 262153 rather than 9, but for now let's take it on faith that there's a good reason for it.

### Lists

What about lists? Lists are more complicated than atomic vectors, because they're just containers for other data structures that can have different lengths and types. As mentioned earlier, they have SEXPTYPE 19, so a list with three elements will of course start with `19` on the first line and `3` on the second line. Here's an example:

```{r}
show_rds(
  object = list(
    c(TRUE, FALSE), 
    10.2, 
    c("strange", "thing")
  ),
  header = FALSE
)
```

The output here begins with the two lines specifying that it's a list of length three, and then is followed by the RDS representation for the logical vector `c(TRUE, FALSE)`, then the RDS representation for the numeric vector `10.2`, and finally the RDS representation for the character vector `c("strange", "thing")`. If we use some indenting and commenting to make annotate the RDS representation of the list, we might get something like this:

```
19 # it's a list
3  # of length 3

  10  # list entry 1 is logical
   2  # of length 2
   
    1       # value is TRUE
    0       # value is FALSE
      
  14  # list entry 2 is numeric 
   1  # of length 1
   
    10.2    # value is 10.2
    
  16  # list entry 3 is character
   2  # of length 2
   
    262153  # every string starts with this
         7  # this string has 7 characters
   strange  # values are: s, t, r, a, n, g, e
   
    262153  # every string starts with this
         5  # this string has 5 characters
     thing  # values are: t, h, i, n, g
```

### Object attributes

One of the key features of R is that vectors are permitted to have arbitrary metadata: names, classes, attributes. If an R object contains metadata, that metadata must be serialised too. That has some slightly surprising effects. Let's start with this very simple numeric object with two elements:

```{r}
show_rds(object = c(100, 200), header = FALSE)
```

As expected, we see that it has SEXPTYPE 14 (numeric), length 2, and the values it stores are 100 and 200. Nothing out of the ordinary here. However, when we add a name to the object, the RDS output is considerably more complicated:

```{r}
show_rds(object = c(a = 100, b = 200), header = FALSE)
```

Ooooookay, that's weird. First off, we seem to be having the same problem we had with strings. If you were to take the first line of this output at face value you might think that a named numeric vector has SEXPTYPE 526. It doesn't. In the same way that strings don't have a SEXPTYPE of 262153 (the actual number is 9), the 526 here is a little misleading. This is a numeric vector and like all numeric vectors it is SEXPTYPE 14. 

Setting those details aside, notice that the RDS output is very similar to the output we saw when converting a list to RDS. The RDS output contains the numeric vector first (the data), which is then followed by a list (well, technically it's a pairlist) that specifies the attributes. For this object, there's only one attribute:

```
526     # Numeric vector 
2       # with two values

   100     # value 1 
   200     # value 2
   
1026    # Pairlist for attributes
1       # with one pair of entries

   262153  # The attribute is called "names"
   5       # 
   names   # 
   
   16      # The attribute has two values
   2       # 
   
      262153   # First value is "a"
           1   #
           a   # 

      262153   # Second value is "b"
           1   #
           b   #

254   # end of pairlist
```

As an aside, the `254` ending the pairlist isn't completely arbitrary. That's how the RDS format encodes a `NULL` value: 

```{r}
show_rds(NULL, header=FALSE)
```

If you look at the relevant part of the R source code, you see that there are a collection of ["administrative codes"](https://github.com/wch/r-source/blob/79298c499218846d14500255efd622b5021c10ec/src/main/serialize.c#L680-L720) that define something "SEXPTYPE-like" for special values. `NULL` is the one you'd be most likely to encounter though.


## Type/Flag Packing

### Decoding the SEXPTYPE

Throughout this post, I've given the impression that when R serialises an object to RDS format, the first thing it writes is the SEXPTYPE of that object. Technically I wasn't lying, but I was hiding something. What R actually does in that first entry is write a single integer, and [packs multiple pieces of information](https://github.com/wch/r-source/blob/79298c499218846d14500255efd622b5021c10ec/src/main/serialize.c#L722-L738) into the bits that comprise that integer. Only the first eight bits are used to define the SEXPTYPE. Other bits are used as flags indicating other things. Earlier on, I said that a value of 526 actually corresponds to a SEXPTYPE of 14. That becomes clearer when we take a look at the binary representation of 14 and 526. The first eight bits are identical:

```{r}
intToBits(14)
intToBits(526)
```

To extract the SEXPTYPE, what we want to do is ignore all the later bits. I could write a function that uses `intToBits()` to unpack an integer into its binary representation, then sets all the bits except the first eight to 0, and then converts back to an integer ... but there's no need. The thing I just described is a "bitwise AND" operation:

```{r}
decode_sexptype <- function(x) bitwAnd(x, 255)

decode_sexptype(14)
decode_sexptype(526)
```

When I said that those 262153 values we encounter every time a string is serialised actually correspond to a SEXPTYPE of 9, this is exactly what I was talking about:

```{r}
decode_sexptype(262153)
```

The attributes pairlist, which gave us a value of 1026 when the RDS is prined out as text? 

```{r}
decode_sexptype(1026)
```

Those are SEXPTYPE 2, and if we check the [R internals manual](https://cran.r-project.org/doc/manuals/r-release/R-ints.pdf) again, we see that this is indeed the code for a pairlist.

### What's in the other bits?

On the off chance that anyone could be bothered reading up to this point, you might be wondering what information is stored in those other bits. There are a few different things in there. The two you'd most likely encounter are the object flag (bit 9) and the attributes flag (bit 10). For example, consider the data frame below:

```{r}
data.frame(
  a = 1, 
  b = 2
)
```

has an integer code of 787. Data frames are just lists with additional metadata, so it's not surprising that when we extract the SEXPTYPE we get a value of 19:

```{r}
decode_sexptype(787)
```

But data frames are also more than lists. They have an explicit S3 class (`"data.frame"`) and they have other attributes too: `"names"` and `"row.names"`. If we unpack the integer code 787 into its constituent bits we see that bit 9 and bit 10 are both set to 1: 

```{r}
intToBits(787)
```

Bit 9 is the "object flag": it specifies whether or not the R data structure has a class attribute. Bit 10 is the more general one, and is called the "attribute flag": it specifies whether or not the object has any attributes.

### Okay but what's up with 262153?

Ugh. Fine. If we unpack the integer code 262153, we see that there's something encoded in bit 19:

```{r}
intToBits(262153)
```

I haven't found the part of the source code that sets this bit yet, but I'm pretty sure that the role of this bit is to flag whether or not the string should be added to the global string pool. In recent versions of R that's true for all strings, so in practice every string has an integer code of 262153 rather than 9.

## Are we done yet?

Depends. If you mean "have we described everything there is to know about the RDS format and how data serialisation works in base R?" then no, we're absolutely not done. I haven't said anything about how R serialises functions or expressions:

```{r}
expr <- quote(sum(a, b, c))
fn <- function(x) x + 1 
```

These are both R objects and you can save them to RDS files. So of course there's a serialisation format for those but it's not a lot of fun. I mean, if you squint at it you can kiiiiiinnnnda see what's going on for the expression

```{r}
show_rds(expr, header = FALSE)
```

but if I were to do the same thing for the function it's just unpleasant, and frankly I already have a headache just from getting this far. So if you mean "have we reached the point where the author is sick of this topic?" then... oh my god yes we are utterly and completely *done* with this subject.

Now let us never speak of this again.



<!--------------- appendices ----------------->

```{r, echo=FALSE}
refinery::insert_appendix(
  repo_spec = params$repo,
  name = paste(params$date, params$slug, sep = "_")
)
```


<!--------------- miscellanea ----------------->

```{r redirect, echo=FALSE}
refinery::insert_netlify_redirect(
  slug = params$slug, 
  date = params$date
)
```




