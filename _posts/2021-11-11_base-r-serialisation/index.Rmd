---
title: "Data serialisation in R"
description:
  Understanding the relationship between in-memory data structures in R and how
  those objects are converted to a sequence of bytes that can be saved or 
  transmitted.
author:
  - first_name: "Danielle"
    last_name: "Navarro"
    url: https://djnavarro.net
    affiliation: UNSW Sydney
    affiliation_url: https://unsw.edu.au
    orcid_id: 0000-0001-7648-6578
date: 2021-11-11
preview: preview-image.jpg  # <---- UPDATE ME 
creative_commons: CC BY
citation_url: https://blog.djnavarro.net/base-r-serialisation 
repository_url: https://github.com/djnavarro/distill-blog/
output:
  distill::distill_article:
    self_contained: false
    toc: true
params:
  slug: base-r-serialisation
  date: 2021-11-11
  repo: djnavarro/distill-blog
  site: https://blog.djnavarro.net/
---

<!----

checklist:
  - check the "update me" messages in YAML above
  - initialise the _renv folder with refinery::renv_new("name of post folder")
  - populate the lockfile with refinery::renv_snapshot("name of post folder")
  - update the _renv folder from snapshot with refinery::restore("name of post folder")

---->


<!--------------- setup post ----------------->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
refinery::renv_load(paste(params$date, params$slug, sep = "_"))
```


<!--------------- post ----------------->

Data [serialisation](https://en.wikipedia.org/wiki/Serialization) is one of those terms that comes up from time to time in data science (and on #rstats twitter!). I suspect that anyone who works with big data or has a computer science background is likely to be *painfully* aware of what serialisation is and why it matters. Those folks probably aren't in need of any post that I might write on the topic! However, a lot of people who work in R come from other backgrounds. If you're a social scientist who mostly works with small CSV files, for example, there's no particular reason why you'd have encountered this. I worked as a mathematical psychologist and computational modeller for about 20 years and until very recently I've never had never had to think about it! In fact, the issue only came up for me when I started reading about [Apache Arrow](https://arrow.apache.org) (a topic for another post, perhaps...) and realised that I needed to have a better understanding of what all this data serialisation business is about, and how R handles it. 

## What do we mean by "serialisation"?

Viewed in the general sense, serialisation refers to any process that takes an object stored in memory and converts into a stream of bytes that can be written to a file or transmitted elsewhere. Any time we write data to a file, we are "serialising" it according to some encoding scheme.  Suppose, for instance, I have a data frame called `art`:

```{r read-csv-hidden, echo=FALSE}
art <- read.csv("art.csv")
```
```{r show-art}
art
```

This data frame is currently stored in memory on my machine, and it has structure: R represents it as a list of length 6, where each element of the list points to an atomic vector (e.g., numeric, character, logical), accompanied by some additional metadata that tells R that this particular list is a data frame. The details of how this is accomplished don't matter for this post^[If you really want to torture yourself you can go look at the [R Internals Manual](https://cran.r-project.org/doc/manuals/r-release/R-ints.pdf)]: all that matters is that the in-memory structure for `art` is a little more complicated than a stream of bytes. If I want to save it to a data file, however, it needs to be converted into a stream of bytes: it needs to be **serialised**. Serialisation doesn't have to be fancy. The humble CSV file is a form of serialisation:

```{r write-csv}
write.csv(art, file = "art.csv", row.names = FALSE)
```

By doing this, the `art` object is written as UTF-8 encoded text onto the disk, as the file "art.csv". If we were to open this file in a text editor, we'd see this:


```{r print-text-csv, echo=FALSE}
print_text_csv <- function(file, nchars = 1000) {
  con <- file(file)
  chars <- readChar(con, nchars = nchars)
  close(con)
  return(chars)
}
cat(print_text_csv("art.csv"))
```

What you see in the text editor, however, isn't literally the raw sequence of bytes: you're looking at it as UTF-8 plain text. The file has already been unserialised and decoded. To get a sense of what the serialised data look like, note that the first few characters of the file are `"resolu"`, and we can use `charToRaw()` to convert these characters into a series of bytes:

```{r}
charToRaw('"resolu')
```

To see what the file looks like in serialised form, we can define a simple helper function that opens a binary connection to the file, reads in the first 100 bytes, closes the file, and then returns those bytes as a raw vector: 

```{r print-bytes-csv}
read_bytes <- function(path, max_bytes = 100) {
  con <- file(path, open = "rb")
  bytes <- readBin(con, what = raw(), n = max_bytes)
  close(con)
  return(bytes)
}

read_bytes("art.csv")
```

The `read.csv()` function is similar to `read_bytes()` in spirit: when I call `read.csv("art.csv")` R R opens a connection to the "art.csv" file and reads that sequence of bytes into memory, and then closes the file. However, unlike my simple `read_bytes()` function, it actually does something useful. The sequence of bytes gets decoded, or **deserialised**, and the result is that R reconstructs the original `art` data frame in memory:

```{r read-csv}
art <- read.csv("art.csv")
art
```

Thrilling stuff.

## How does the RDS serialisation format work?

Data can be serialised in different ways. The native RDS format used by R, for example, provides a method for serialising an R object in a way that -- unlike CSV -- preserves all the information about that object. When I use `readRDS()` to unserialise the `art.rds` file that I happen to have on disk, it clearly recreates the same R object

```{r read-rds}
readRDS("art.rds")
```

but when I read this file using `read_bytes()` it's equally clear that the file itself contains a very different sequence of bytes:

```{r read-rds-bytes}
read_bytes("art.rds")
```

To get a sense of how the RDS format works, it's helpful to note that R has a `serialize()` function and an `unserialize()` function that provide low-level access to the same mechanisms that underpin `saveRDS()` and `readRDS()`. 

```{r serialise-art}
bytes <- serialize(art, connection = NULL)
```

As you can see, this is the same sequence of bytes returned by `read_bytes()`...

```{r show-serialised}
bytes[1:100]
```

...oh wait, not it's not. The "art.rds" file begins with `1f 8b 08 00`, whereas `serialize()` returns a sequence of bytes that begins with `58 0a 00 00`. These are clearly not the same!

The reason this happens is that the default behaviour of `saveRDS()` is to write a compressed RDS file using gzip compression. The `art.rds` file that I have stored on disk is that gzipped version. That's a very sensible default, but it's easy enough to save an uncompressed RDS file, simply by setting `compress = FALSE`:

```{r save-uncompressed}
saveRDS(art, file = "art_nozip.rds", compress = FALSE)
```

When I inspect the uncompressed version of the RDS file using `read_bytes()`, the output is the same one I obtained when I called `serialize(art)` earlier:

```{r read-uncompressed}
read_bytes("art_nozip.rds")
```

The `unserialize()` function is very similar to `readRDS()`, and you can apply it to a raw vector like `bytes` and once again we reconstruct the data frame:

```{r unserialise-art}
unserialize(bytes)
```

Even more thrilling stuff than before. 

## Serialising data to plain text RDS with UTF-8

Okay, so what we've learned so far is that in most cases, an RDS file is just a gzipped version of whatever the hell it is that `serialize()` creates. What we don't yet know is how the `serialize()` function operates. How is it creating this sequence of bytes? What do the contents of this file actually include? In order to look at this, I'll start by serialising a much simpler object. Instead of serialising the `art` data frame, I'll serialise a numeric vector containing three elements, and I'll set `ascii = TRUE` so that R uses UTF-8 to serialise the object to plain text format

```{r}
bytes <- serialize(
  object = c(10.1, 2.2, 94.3), 
  connection = NULL,
  ascii = TRUE
)
```

When I print out the UTF-8 vector I still don't get text though, I get the sequence of bytes that corresponds to that text:

```{r}
bytes
```

However, it's easy enough to use `rawToChar()` to convert the raw vector into a text that I can then print out using `cat()`:

```{r}
cat(rawToChar(bytes))
```

It's not immediately obvious how this output should be interpreted, but it's clear that the last three lines correspond to the three values stored in the numeric vector. In fact, what you're looking at is exactly the same text that you'd see if you created an RDS using the following command and then opened that file in a text editor:

```{r}
saveRDS(
  object = c(10.1, 2.2, 94.3), 
  file = "numbers.rds", 
  ascii = TRUE, 
  compress = FALSE
)
```

Yay! My excitement can barely be contained.

## Interpreting the contents of an RDS file

All right, lets see if we can interpret the contents of an RDS file. Rather than tediously writing the file to disk using `saveRDS()` and then loading it again, I'll cheat slightly and write a `format_rds()` function that serialises an object and prints the results directly to the R console:

```{r}
format_rds <- function(object) {
  bytes <- serialize(
    object = object,
    connection = NULL, 
    ascii = TRUE
  )
  cat(rawToChar(bytes))
}
```

Okay, so here's our RDS-formatted object:

```{r}
format_rds(object = c(10.1, 2.2, 94.3))
```

We already know what the last 3 lines mean: they're the 3 values contained in the object. Is it a coincidence that line preceding that happens to *also* contain "3"? Let's see what happens if we try to serialise just 2 numbers. Does that line change to "2"?

```{r}
format_rds(object = c(10.1, 2.2))
```

Yes. Yes it does. Here's what we know so far:

```
A
3
262402
197888
5
UTF-8
14
3      # the object has length 3
10.1   # first value is 10.1
2.2    # second value is 2.2
94.3   # third value is 94.3
```

Okay, so what's next? The "14" in the preceding line. What does that mean? Well, if you happen to be the kind of person who has the [R Internals Manual](https://cran.r-project.org/doc/manuals/r-release/R-ints.pdf)] open at all times (and who doesn't amirite?), you would *obviously* that 14 is the internal `SEXPTYPE` code that R uses to specify that an object is a numeric vector. But just case you happen to be a human being with a life and doesn't have the R Internals Manual memorised, here's a few of the more common codes:

| Value | SEXPTYPE | Variable type   |
| ----- | -------- | --------------- | 
| 10    | LGLSXP   | logical         |
| 13    | INTSXP   | integer         |
| 14    | REALSXP  | numeric         |
| 16    | STRSXP   | character       |
| 19    | VECSXP   | list            |

So we can update our annotated description:

```
A
3
262402
197888
5
UTF-8
14     # the object is numeric
3      # the object has length 3
10.1   # first value is 10.1
2.2    # second value is 2.2
94.3   # third value is 94.3
```

At this point, we've annotated every part of the RDS file that corresponds to the actual object. The lines preceding it are the RDS header. Here's what the first four lines mean:

```
A      # the file uses ASCII encoding
3      # the file uses version 3 of the RDS format
262402 # the file was written in R version 4.1.2
197888 # the minimum R version that can read it is 3.5
5
UTF-8 
```

At this point any sane person is probably wondering how the R versions are encoded. Why does version 4.1.2 correspond to the number 262402, and why does 3.5 get encoded as 197888? It was a complete mystery to me until I took a look at the internal [source code](https://github.com/wch/r-source/blob/79298c499218846d14500255efd622b5021c10ec/tools/GETVERSION#L11) which revealed the formula:

```{r}
encode_r_version <- function(major, minor, patch) {
  (major * 65536) + (minor * 256) + patch
}
```

Just to check:

```{r, results='hold'}
encode_r_version(4, 1, 2)
encode_r_version(3, 5, 0)
```

Okay, that all makes sense. What about the other two lines in the header? Prior to RDS version 3 (which was released in R version 3.5) those two lines didn't exist. Those are now used to specify the "native encoding" of the file. The "A" at the beginning of the RDS file is a little misleading: the RDS file format isn't restricted to ASCII characters. In the usual case, the RDS file can encode any [UTF-8 character](https://en.wikipedia.org/wiki/UTF-8). In some cases, however, the file may be restricted to the [Latin-1 alphabet](https://en.wikipedia.org/wiki/ISO/IEC_8859-1). Because of this, there is some ambiguity that needs to be resolved: the RDS file needs to indicate which character set is used for the encoding. So our annotated header now looks like this:

```
A      # the file uses ASCII encoding
3      # the file uses version 3 of the RDS format
262402 # the file was written in R version 4.1.2
197888 # the minimum R version that can read it is 3.5
5
UTF-8  # the file encodes UTF-8 characters not Latin-1
```

Okay then... but what about that pesky "5"? What does that mean? I'll be honest. It took me ages to figure this one out. As far as I can tell this line isn't discussed in the R Internals Manual, but you can work it out by looking at the [source code for serialize](https://github.com/wch/r-source/blob/79298c499218846d14500255efd622b5021c10ec/src/main/serialize.c#L1405-L1408). That line reads "5" because it's telling you (or the parser) that the string that follows on the next line (i.e., "UTF-8") contains 5 characters. Presumably if I'd used Latin-1 encoding, the corresponding line would have been "7". 


<!--------------- appendices ----------------->

```{r, echo=FALSE}
refinery::insert_appendix(
  repo_spec = params$repo,
  name = paste(params$date, params$slug, sep = "_")
)
```


<!--------------- miscellanea ----------------->

```{r redirect, echo=FALSE}
refinery::insert_netlify_redirect(
  slug = params$slug, 
  date = params$date
)
```




