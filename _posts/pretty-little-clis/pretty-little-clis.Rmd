---
title: "Pretty little CLIs"
description: |
  How to make a gorgeous command line interface in R using the cli package.
author:
  - name: Danielle Navarro
    url: https://djnavarro.net
date: 04-16-2021
bibliography: pretty-little-clis.bib
output:
  distill::distill_article:
    self_contained: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# enable ANSI to HTML using the fansi package: ensures that the
# ANSI terminal colours are translated into HTML correctly
options(crayon.enabled = TRUE)
knitr::knit_hooks$set(output = function(x, options){
  paste0(
    "<pre class=\"r-output\"><code>",
    fansi::sgr_to_html(x = x, warn = FALSE, term.cap = "256"),
    "</code></pre>"
  )
})

# uncomment this line to generate the asciicast svgs
# source(here::here("_posts", "pretty-little-clis", "source", "create-asciicasts.R"))

# convenience function to insert an asciicast svg
insert_asciicast <- function(name) {
  dir <- here::here("_posts", "pretty-little-clis", "output")
  svg <- paste0(name, ".svg")
  knitr::include_graphics(file.path(dir, svg))
}

# create a cli app that directs output to stdout() rather than
# stderr() to ensure that R markdown will show the output
app <- cli::start_app(output = "stdout", .auto_close = TRUE)
```


If you've been working in R for any length of time, you've probably realised that you sometimes need to write code that prints information to the R console, and if you're like me you've learned that the simplest way to do this is to use the `cat()` function. Perhaps you find yourself writing code like this:

```{r cat-example, eval=FALSE}
wait <- function(seconds = 2) {Sys.sleep(seconds)}
simple_message <- function() {
  cat("Dead girls walking.")
  wait()
  cat(" --A.\n")
}
simple_message()
```

<aside>
The ominous text messages used in this post are taken from the TV show [*Pretty Little Liars*](https://prettylittleliars.fandom.com/)
</aside>

In a realistic example, the `wait()` function would likely be something that takes some time to complete, and the lines above and below are a polite way to let your user (even if that's just you!) know when the waiting process starts and when it finishes. In any case, when you source a script containing this code, the first part of the message will appear on the console immediately:

```{r cat-example-partial, echo=FALSE}
cat("Dead girls walking.")
```

Then after a two second delay, the console updates to reveal that the author of the threatening message is the mysterious "A." character:

```{r, ref.label="cat-example", echo=FALSE, eval=TRUE}
```

It's not too difficult to imagine what this looks like in the console, but courtesy of the [asciicast](https://github.com/r-lib/asciicast) package [@asciiicast], there's no need to leave anything to the imagination:

```{r display-cat-example, echo=FALSE}
insert_asciicast("cat-example")
```

This approach works perfectly well for simple text communication, but sometimes you want something that looks a little nicer. After all, if you're planning to impersonate a dead teenager and terrorise her friends using R, you might as well put a little effort into the details, right?

## Meet the cli package

If you've worked in the [tidyverse](https://www.tidyverse.org/) [@tidyverse] for any length of time you will have noticed that messages produced by tidyverse packages seem to have a more polished look to them. Perhaps, like me, you've wondered how the magic works and if you too can create pretty messages at the console. As it happens, many wonderful things become possible if you happen to have the [cli](https://cli.r-lib.org) package [@cli] as your talented assistant, and in this post I'll talk about some of them. 

To craft a beautiful command line interface (CLI) of our very own, the first thing we'll need to do is load the package:

```{r package-load, message=FALSE, warning=FALSE}
library(cli)
```

The design of cli separates style from structure: your messaging code specifies the *structure* associated with the message, not the superficial *style*. The `cli_h1()` command generates a "top-level" heading, the `cli_h2()` command generates a second level heading, `cli_text()`inserts basic, and so on. So the code you write might look something like this:

```{r message-structure-1, eval=FALSE}
title_theme <- function() {
  cli_h1("Secret, by The Pierces")
  cli_text("Got a secret, can you keep it?")
  cli_text("Swear this one you'll save")
  cli_text("Better lock it in your pocket")
  cli_text("Taking this one to the grave")
  cli_text("If I show you then I know you won't tell what I said")
  cli_text("Cause two can keep a secret if one of them is dead")
}
title_theme()
```

When this code is executed, the cli package applies the appropriate styling to create the actual output. You can customise this style using the theming system in cli, but I've never felt a need to do so because the default theme is rather nice:

```{r, ref.label="message-structure-1", eval=TRUE, echo=FALSE}
```

Sometimes you may prefer send the user short alert messages. You can create generic alerts with `cli_alert()` or you could be more specific by using `cli_alert_info()`, `cli_alert_warning()`, `cli_alert_danger()`, `cli_alert_success()`. Most of the text messages sent by A. in *Pretty Little Liars* were quite threatening, so in this case it might be more appropriate to mark it as one:

```{r message-structure-2}
threatening_text <- function() {
  cli({
    cli_alert_warning("The truth won't set you free, bitches.")
    cli_alert_warning("I'm going to bury you with it.")
    cli_alert_warning("Kisses")
    cli_alert_warning("-A")
  })
}
threatening_text()
```

Note that I wrapped it in a call to `cli()`: this has the effect of telling R to group all these as a single message, and in doing so makes sure that they aren't ever displayed separately. Often that's what you want, but not necessarily. For example, most of the time there's some code in between each message that takes some time to execute. If we wanted the title theme to reveal itself gradually, scrolling up the screen as it does

```{r message-structure-3, eval=FALSE}
title_theme_scroll <- function() {
  cli_h1("Secret, by The Pierces"); wait()
  cli_text("Got a secret, can you keep it?"); wait()
  cli_text("Swear this one you'll save"); wait()
  cli_text("Better lock it in your pocket"); wait()
  cli_text("Taking this one to the grave"); wait()
  cli_text("If I show you then I know you won't tell what I said"); wait()
  cli_text("Cause two can keep a secret if one of them is dead"); wait()
}
title_theme_scroll()
```
```{r display-message-structure-3, echo=FALSE}
insert_asciicast("message-structure-3")
```

<aside>
The theme song is *Secrets*, the first track from the 2007 album [Thirteen Tales of Love and Revenge](https://en.wikipedia.org/wiki/Thirteen_Tales_of_Love_and_Revenge) by *The Pierces*
</aside>




## Status Bars

In this instance, the output happens to be identical to our first example: all it does is print the lyrics to the music in the title credits from *Pretty Little Liars*, with a brief pause between each line. However the R console has many dark secrets, and fancier tricks than this are possible once you know a few...

```{r status-bar-1, eval=FALSE}
message_scroll <- function() {
  cli_text("You found my bracelet."); wait()
  cli_text("Now come find me."); wait()
  cli_text("Good luck bitches."); wait()
  cli_text("-A"); wait()
}
message_scroll()
```
```{r display-status-bar-1, echo=FALSE}
insert_asciicast("status-bar-1")
```

```{r status-bar-2, eval=FALSE}
message_inline <- function() {
  id <- cli_status("")
  cli_status_update(id, "You found my bracelet."); wait()
  cli_status_update(id, "Now come find me."); wait()
  cli_status_update(id, "Good luck bitches."); wait()
  cli_status_update(id, "-A"); wait()
  cli_status_clear(id)
}
message_inline()
```
```{r display-status-bar-2, echo=FALSE}
insert_asciicast("status-bar-2")
```

## Spinners

```{r spinner-1, eval=FALSE}
theatrics <- function(which) {
  spinny <- make_spinner(
    which = which,
    template = "{spin} It's not over until I say it is."
  )
  for(i in 1:100) {
    spinny$spin()
    wait(.05)
  }
  spinny$finish()
  cli_alert_success("Sleep tight while you still can, bitches. -A")
}

theatrics("dots2")
```
```{r display-spinner1, echo=FALSE}
insert_asciicast("spinner-1")
```

There are quite a few possible spinners

```{r list-spinners}
list_spinners()
```

```{r spinner-2, eval=FALSE}
theatrics("hearts")
```
```{r display-spinner2, echo=FALSE}
insert_asciicast("spinner-2")
```

